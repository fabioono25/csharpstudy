# Chapter 11 --- C# 10.0: Cleaner Codebases

## Summary
Released in 2021 with .NET 6, C# 10.0 continued the trend of removing boilerplate code. It introduced features that allow developers to declare common namespaces globally and simplify file structures, resulting in significantly cleaner and shorter files.

## Highlights & Internal Changes
*   **Interpolated String Handlers**: A performance optimization that allows custom logic for processing interpolated strings, reducing allocations.

## Topics

### Global usings

#### Summary
**Global usings** allow you to define `using` directives that apply to the entire project. This removes the need to repeat common namespaces like `System` or `System.Linq` in every file.

#### Motivation / When to Use
*   **Boilerplate Reduction**: Remove noise from the top of every file.
*   **Common Libraries**: Include core namespaces (System, generic collections) globally.
*   **Test Projects**: Globally include testing frameworks (Xunit, NUnit).

#### Benefits
*   **Cleaner Files**: Focus on code, not imports.
*   **Consistency**: Ensure standard namespaces are available everywhere.

#### Improvements (C# specifics)
*   Can be defined in any `.cs` file (usually `GlobalUsings.cs`).
*   Can be auto-generated by the SDK (Implicit Usings).

#### Example
```csharp
// GlobalUsings.cs
global using System;
global using System.Collections.Generic;
global using System.Linq;
global using static System.Console; // Static imports work too!

// AnyOtherFile.cs
// No need for 'using System;' here
public void Log() => WriteLine("Hello");
```

#### Line-by-Line Explanation
*   `global using ...`: Makes the namespace available in all files in the compilation.

#### Tests
[2 - GlobalUsings.cs](../../CSharpStudy.Tests/CSharp10/2%20-%20GlobalUsings.cs)

#### Common Pitfalls / Gotchas
*   **Conflicts**: Global usings can cause naming conflicts if two namespaces have the same type name.
*   **Visibility**: It's harder to see where a type comes from if the using isn't in the file.

#### Best Practices / Checklist
*   Create a dedicated `GlobalUsings.cs` file.
*   Don't overuse; keep specific/rare namespaces local.
*   Use `<ImplicitUsings>enable</ImplicitUsings>` in csproj for defaults.

#### Related Topics
*   Using Directives
*   Implicit Usings

### File-scoped namespaces

#### Summary
**File-scoped namespaces** allow you to declare the namespace for the entire file with a single line, eliminating the need for block indentation (curly braces).

#### Motivation / When to Use
*   **Standard Files**: Most C# files contain only one class in one namespace.
*   **Indentation**: Save horizontal space (the "tab tax").

#### Benefits
*   **Concise**: Removes one level of nesting.
*   **Aesthetic**: Code starts closer to the left margin.

#### Improvements (C# specifics)
*   Mutually exclusive with block-scoped namespaces in the same file.
*   Applies to all types defined in the file.

#### Example
```csharp
namespace MyProject.Models; // Semicolon, no braces

public class User
{
    public string Name { get; set; }
}

public class Order
{
    // ...
}
```

#### Line-by-Line Explanation
*   `namespace ...;`: Declares that everything following belongs to this namespace.

#### Tests
[3 - FileScopedNameDeclaration.cs](../../CSharpStudy.Tests/CSharp10/3%20-%20FileScopedNameDeclaration.cs)

#### Common Pitfalls / Gotchas
*   **Multiple Namespaces**: Cannot define multiple namespaces in one file (rarely needed anyway).

#### Best Practices / Checklist
*   Adopt as the default for all new files.
*   Convert existing files to reduce nesting.

#### Related Topics
*   Namespaces

### Record Structs

#### Summary
**Record Structs** bring the benefits of records (value equality, `ToString`, `Deconstruct`, `with` expressions) to value types (`struct`).

#### Motivation / When to Use
*   **Performance**: Stack-allocated data models (no GC pressure).
*   **Small Data**: Coordinates, complex numbers, small DTOs.
*   **Equality**: Need value semantics for equality.

#### Benefits
*   **Efficiency**: No heap allocation.
*   **Features**: Get `Equals`, `ToString`, etc., for free.

#### Improvements (C# specifics)
*   `record struct`: Mutable by default (like standard structs).
*   `readonly record struct`: Immutable (recommended).
*   `record class`: Explicit name for reference type records (optional, `record` implies class).

#### Example
```csharp
// Mutable record struct
public record struct Point(int X, int Y);

// Immutable record struct (Recommended)
public readonly record struct Coords(double Lat, double Lon);

var p1 = new Point(1, 2);
var p2 = new Point(1, 2);
Console.WriteLine(p1 == p2); // True
```

#### Line-by-Line Explanation
*   `record struct`: Defines a value type record.
*   `readonly`: Enforces immutability.

#### Tests
[1 - RecordStructs.cs](../../CSharpStudy.Tests/CSharp10/1%20-%20RecordStructs.cs)

#### Common Pitfalls / Gotchas
*   **Mutability**: `record struct` is mutable by default (unlike `record class`).
*   **Size**: Large structs are expensive to copy; pass by `ref` or `in`.

#### Best Practices / Checklist
*   Prefer `readonly record struct` for immutability.
*   Use for small, data-centric types.

#### Related Topics
*   Records (C# 9.0)
*   Structs

### Lambda improvements (explicit return type)

#### Summary
**Lambda improvements** include "natural type" inference (compiler guesses `Func` or `Action`), explicit return types, and attributes on lambdas.

#### Motivation / When to Use
*   **Minimal APIs**: `app.MapGet("/", [Authorize] () => "Hello");`
*   **Type Inference**: `var f = () => "Hello";` (now works, inferred as `Func<string>`).
*   **Ambiguity**: `var f = object (int x) => x;` (explicitly return `object` instead of `int`).

#### Benefits
*   **Usability**: Less casting (`(Func<string>)(() => "...")`).
*   **Flexibility**: Attributes enable metadata for frameworks (ASP.NET Core).

#### Improvements (C# specifics)
*   **Natural Type**: Compiler infers delegate type.
*   **Explicit Return Type**: Syntax `ReturnType (args) => body`.

#### Example
```csharp
// Natural type inference
var greet = () => "Hello World"; // Inferred as Func<string>

// Explicit return type
var choose = object (bool b) => b ? 1 : "Two"; // Returns object

// Attributes (see next section)
```

#### Line-by-Line Explanation
*   `object (bool b)`: Explicitly states the lambda returns `object`.

#### Tests
[5 - LambdaImprovements.cs](../../CSharpStudy.Tests/CSharp10/5%20-%20LambdaImprovements.cs)

#### Common Pitfalls / Gotchas
*   **Null**: `var f = () => null;` still fails (cannot infer type of null). Needs cast or explicit type.

#### Related Topics
*   Delegates
*   Anonymous Methods

### Constant Interpolated Strings

#### Summary
**Constant Interpolated Strings** allow you to use string interpolation (`$""`) inside `const` string declarations, provided all interpolated values are also constants.

#### Motivation / When to Use
*   **Attributes**: Constructing attribute arguments (which must be const).
*   **Versioning**: Combining version numbers.
*   **Paths**: Building constant file paths.

#### Benefits
*   **Readability**: Replaces `String.Format` or `+` concatenation in constants.
*   **Compile-Time**: Resolved at compile time, no runtime cost.

#### Improvements (C# specifics)
*   Previously, `const string s = $"{a}{b}"` was a compile error.

#### Example
```csharp
const string BaseUrl = "https://api.example.com";
const string Version = "v1";
const string Endpoint = $"{BaseUrl}/{Version}/users"; // Valid in C# 10

[Obsolete($"Use {Endpoint} instead")]
public void OldMethod() { }
```

#### Line-by-Line Explanation
*   `const string Endpoint`: Computed at compile time.
*   `[Obsolete(...)]`: Can use the constant because it's known at compile time.

#### Tests
[8 - ConstantInterpolatedStrings.cs](../../CSharpStudy.Tests/CSharp10/8%20-%20ConstantInterpolatedStrings.cs)

#### Common Pitfalls / Gotchas
*   **Non-Const**: If any part is not `const`, it fails. `static readonly` is not enough.
*   **Numbers**: Interpolating numbers (e.g., `const int i = 1; $"{i}"`) is NOT allowed because `ToString()` is runtime. Only strings.

#### Best Practices / Checklist
*   Use for constructing complex constant strings.
*   Ensure all components are strings.

#### Related Topics
*   String Interpolation
*   Constants

### Extended Property Patterns

#### Summary
**Extended Property Patterns** allow you to match nested properties directly using dot notation (`Prop.ChildProp`) inside a pattern, making it cleaner than nested braces.

#### Motivation / When to Use
*   **Deeply Nested Objects**: Checking properties of sub-objects.
*   **Configuration Validation**: Validating nested config settings.

#### Benefits
*   **Readability**: Less nesting depth.
*   **Conciseness**: Shorter syntax.

#### Improvements (C# specifics)
*   Replaces `{ Address: { City: "Seattle" } }` with `{ Address.City: "Seattle" }`.

#### Example
```csharp
if (person is { Address.City: "Seattle", Age: >= 18 })
{
    Console.WriteLine("Adult from Seattle");
}

// Old way (C# 8)
if (person is { Address: { City: "Seattle" }, Age: >= 18 }) { ... }
```

#### Line-by-Line Explanation
*   `Address.City`: Accesses the `City` property of the `Address` property.
*   `"Seattle"`: The constant pattern to match against.

#### Tests
[7 - ExtendedPropertyPatterns.cs](../../CSharpStudy.Tests/CSharp10/7%20-%20ExtendedPropertyPatterns.cs)

#### Common Pitfalls / Gotchas
*   **Null Checks**: Implicitly checks for null. If `Address` is null, the pattern fails (does not throw).

#### Best Practices / Checklist
*   Use dot notation for single properties.
*   Use nested braces if you need to check multiple properties of the *same* nested object.

#### Related Topics
*   Pattern Matching (C# 7/8/9)

### Attributes in Lambdas

#### Summary
**Attributes in Lambdas** allow you to apply attributes to the lambda expression itself, its return value, or its parameters.

#### Motivation / When to Use
*   **Minimal APIs**: ASP.NET Core endpoints defined as lambdas often need attributes like `[Authorize]` or `[FromQuery]`.
*   **Validation**: Applying validation attributes to parameters.

#### Benefits
*   **Metadata**: Provides necessary metadata to frameworks using reflection.
*   **Parity**: Brings lambdas closer to full methods.

#### Improvements (C# specifics)
*   Syntax uses `[Attr]` before the lambda or parameter.

#### Example
```csharp
// Attribute on the method (lambda)
var handler = [Authorize] () => "Secure Data";

// Attribute on parameters
var getProduct = ([FromRoute] int id) => Get(id);

// Attribute on return value
var getStatus = [return: NotNull] () => GetStatus();
```

#### Line-by-Line Explanation
*   `[Authorize]`: Applies to the anonymous method generated by the lambda.
*   `[FromRoute]`: Applies to the `id` parameter.

#### Tests
Verified via compiler and framework usage (e.g., ASP.NET Core).

#### Common Pitfalls / Gotchas
*   **Parentheses**: You must use parentheses for parameters if you have attributes, even for a single parameter. `[Attr] x => ...` is invalid; use `([Attr] x) => ...`.

#### Best Practices / Checklist
*   Use primarily when working with frameworks that rely on attributes (like ASP.NET Core Minimal APIs).

#### Related Topics
*   Attributes
*   Lambda Expressions
