# Chapter 6 --- C# 5.0: The Asynchronous Evolution

## Summary
Released in 2012 with Visual Studio 2012, C# 5.0 had a singular but transformative focus: **Asynchronous Programming**. Before this version, writing responsive applications (UI) or high-throughput servers required complex callback chains or manual thread management. C# 5.0 introduced the `async` and `await` keywords, abstracting this complexity into a state machine generated by the compiler.

## Highlights & Internal Changes
*   **State Machine Generation**: The compiler transforms `async` methods into a state machine structure that handles suspending and resuming execution, preserving local variables and context.
*   **Caller Info Attributes**: Added to support tracing and logging (e.g., `[CallerMemberName]`).

## Topics

### `async` / `await` keywords

#### Summary
**`async`** marks a method as asynchronous. **`await`** pauses the method's execution until the awaited `Task` completes, without blocking the thread. The compiler transforms the method into a state machine.

#### Motivation / When to Use
*   **UI Responsiveness**: Keep WPF/WinForms/Blazor UI threads free during I/O.
*   **Server Scalability**: Free up ASP.NET threads during database/network calls.
*   **I/O Operations**: File, HTTP, database operations.

#### Benefits
*   **Readability**: Async code reads like synchronous code.
*   **No Manual Callbacks**: No more nested callbacks or ContinueWith chains.
*   **Exception Propagation**: Standard try/catch works.

#### Improvements (C# specifics)
*   **`async Task`**: Non-blocking void equivalent.
*   **`async Task<T>`**: Returns value after completion.
*   **`async void`**: Only for event handlers (avoid otherwise).

#### Example
```csharp
public async Task<string> FetchDataAsync(string url)
{
    using var client = new HttpClient();
    string result = await client.GetStringAsync(url);
    return result.ToUpper();
}

// Usage
string data = await FetchDataAsync("https://api.example.com");
```

#### Line-by-Line Explanation
*   `async Task<string>`: Method returns `Task<string>`, can be awaited.
*   `await client.GetStringAsync(...)`: Pauses here; thread is freed until response arrives.
*   Code after `await` resumes when task completes.

#### Tests
[1 - AsyncMethods.cs](../../CSharpStudy.Tests/CSharp5/1%20-%20AsyncMethods.cs)

```csharp
[Fact]
public async Task AsyncMethod_ReturnsResult()
{
    async Task<int> GetValueAsync() => await Task.FromResult(42);
    
    int result = await GetValueAsync();
    Assert.Equal(42, result);
}
```

#### Common Pitfalls / Gotchas
*   **`async void`**: Cannot be awaited, swallows exceptions. Only use for event handlers.
*   **Deadlock**: Calling `.Result` or `.Wait()` on UI thread causes deadlock.
*   **ConfigureAwait**: Use `ConfigureAwait(false)` in libraries to avoid context capture.

#### Performance Notes
*   Allocates a state machine; for very hot paths, consider `ValueTask<T>`.
*   Avoid `async` for synchronous-only methods (overhead without benefit).

#### Best Practices / Checklist
*   Suffix async methods with `Async`.
*   Use `async Task`, not `async void`.
*   Always await or handle returned Tasks.

#### Related Topics
*   TAP (Task-based Asynchronous Pattern)
*   `ValueTask<T>` (C# 7.0)
*   Async Streams (C# 8.0)

### TAP model (`Task` and `Task<T>`)

#### Summary
**Task-based Asynchronous Pattern (TAP)** is the standard for asynchronous operations in .NET. `Task` represents an operation, and `Task<T>` represents an operation that returns a value.

#### Motivation / When to Use
*   **All async operations**: HTTP, file I/O, database access.
*   **Parallel work**: Combine multiple tasks with `Task.WhenAll`.

#### Benefits
*   **Composable**: Chain, combine, and transform tasks.
*   **Unified Pattern**: Replaces APM (Begin/End) and EAP (Event-based).

#### Improvements (C# specifics)
*   **`Task.Run`**: Offload CPU-bound work to thread pool.
*   **`Task.FromResult`**: Create completed tasks for caching/testing.

#### Example
```csharp
// CPU-bound work
Task<int> task = Task.Run(() => ExpensiveCalculation());
int result = await task;

// Combining multiple tasks
Task t1 = LoadDataAsync();
Task t2 = LoadImagesAsync();
await Task.WhenAll(t1, t2);
```

#### Line-by-Line Explanation
*   `Task.Run(...)`: Runs lambda on thread pool.
*   `Task.WhenAll(...)`: Returns when all tasks complete.

#### Tests
No dedicated test file (covered in async tests).

#### Common Pitfalls / Gotchas
*   **`Task.Run` misuse**: Don't use for I/O-bound operations (they don't need a thread).
*   **Unobserved exceptions**: Tasks that aren't awaited will silently fail.

#### Best Practices / Checklist
*   Use `Task.Run` for CPU work only.
*   Use `await Task.WhenAll` for concurrent I/O.

#### Related Topics
*   async/await
*   `ValueTask<T>`

### Asynchronous Exception Handling

#### Summary
**Async Exception Handling** allows standard `try-catch-finally` blocks within async methods. Exceptions thrown in async operations are captured and re-thrown when the task is awaited.

#### Motivation / When to Use
*   **Error Recovery**: Gracefully handle network failures, timeouts, and invalid data.
*   **Logging**: Capture and log errors from async operations.

#### Benefits
*   **Intuitive**: Same patterns as synchronous code.
*   **Exception Propagation**: Exceptions bubble up correctly.

#### Improvements (C# specifics)
*   Exceptions stored in `Task.Exception` (as `AggregateException`).
*   `await` unwraps and throws the first inner exception.

#### Example
```csharp
try
{
    await HttpClient.GetStringAsync("https://invalid.url");
}
catch (HttpRequestException ex)
{
    Console.WriteLine($"Network error: {ex.Message}");
}
finally
{
    CleanupResources();
}
```

#### Line-by-Line Explanation
*   `await` throws if the task faulted.
*   `catch` handles the exception as normal.

#### Tests
Covered in async tests.

#### Common Pitfalls / Gotchas
*   **`async void`**: Exceptions cannot be caught by the caller.
*   **Unawaited tasks**: Exceptions are lost unless observed.

#### Best Practices / Checklist
*   Always await tasks or handle exceptions via `.ContinueWith`.
*   Use `Task.Exception` for batch error handling with `Task.WhenAll`.

#### Related Topics
*   async/await
*   `AggregateException`

### Synchronization Context

#### Summary
**SynchronizationContext** ensures code after `await` resumes on the correct thread (e.g., UI thread in WPF/WinForms). By default, `await` captures and restores the context.

#### Motivation / When to Use
*   **UI Updates**: Update controls after async work.
*   **Thread Affinity**: Some APIs require a specific thread.

#### Benefits
*   **Automatic**: No manual `Dispatcher.Invoke` needed.
*   **Safe UI Access**: Prevents cross-thread exceptions.

#### Improvements (C# specifics)
*   `ConfigureAwait(false)`: Opts out of context capture for library code.
*   Context captured at `await`, restored on completion.

#### Example
```csharp
// WPF Example
private async void Button_Click(object sender, EventArgs e)
{
    var data = await LoadDataAsync(); // Runs on thread pool
    TextBox.Text = data;              // Back on UI thread automatically
}
```

#### Line-by-Line Explanation
*   `await` captures UI context before yielding.
*   Code after `await` resumes on the captured UI thread.

#### Tests
No automated test (UI-specific feature).

#### Common Pitfalls / Gotchas
*   **Deadlock**: `.Result` or `.Wait()` blocks UI thread while continuation waits for it.
*   **Library Code**: Always use `ConfigureAwait(false)` in libraries.

#### Best Practices / Checklist
*   Use `ConfigureAwait(false)` in reusable libraries.
*   Never use `.Result`/`.Wait()` on UI thread.

#### Related Topics
*   async/await
*   `ConfigureAwait`

<!-- TODO: Consider adding await in catch and finally blocks (C# 6.0 feature, often grouped here for context) -->

### Caller Info Attributes

#### Summary
**Caller Info Attributes** automatically inject caller information into method parameters. `[CallerMemberName]`, `[CallerFilePath]`, and `[CallerLineNumber]` provide debugging and logging context.

#### Motivation / When to Use
*   **Logging**: Automatically include method name in log messages.
*   **INotifyPropertyChanged**: Eliminate hardcoded property names.
*   **Debugging**: Track where methods are called from.

#### Benefits
*   **Compile-Time Resolution**: No runtime reflection cost.
*   **Refactoring Safe**: `nameof`-like benefit for property names.

#### Improvements (C# specifics)
*   Used with optional parameters.
*   Compiler replaces default value with actual caller info.

#### Example
```csharp
public void Log(string msg, 
    [CallerMemberName] string member = "",
    [CallerFilePath] string file = "",
    [CallerLineNumber] int line = 0)
{
    Console.WriteLine($"{file}:{line} [{member}] {msg}");
}

// Usage
Log("Something happened"); 
// Output: C:\src\Program.cs:42 [Main] Something happened
```

#### Line-by-Line Explanation
*   `[CallerMemberName]`: Filled with calling method/property name.
*   `[CallerFilePath]`: Full path to source file.
*   `[CallerLineNumber]`: Line number of the call.

#### Tests
[2 - CallerInfoAttributes.cs](../../CSharpStudy.Tests/CSharp5/2%20-%20CallerInfoAttributes.cs)

```csharp
[Fact]
public void CallerMemberName_CapturesMethodName()
{
    string GetCaller([CallerMemberName] string name = "") => name;
    
    Assert.Equal("CallerMemberName_CapturesMethodName", GetCaller());
}
```

#### Common Pitfalls / Gotchas
*   **Must be optional**: Parameters need default values.
*   **Compile-time only**: Cannot get caller info at runtime dynamically.

#### Best Practices / Checklist
*   Use for logging frameworks.
*   Use with `INotifyPropertyChanged.OnPropertyChanged()`.

#### Related Topics
*   `nameof` operator (C# 6.0)
*   `INotifyPropertyChanged`
